package io.quarkiverse.mapstruct.deployment;

import java.lang.reflect.Modifier;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.quarkus.deployment.dev.RecompilationDependenciesProcessor;
import org.jboss.jandex.AnnotationInstance;
import org.jboss.jandex.ClassInfo;
import org.jboss.jandex.ClassType;
import org.jboss.jandex.DotName;
import org.jboss.jandex.FieldInfo;
import org.jboss.jandex.IndexView;
import org.jboss.jandex.MethodInfo;
import org.jboss.jandex.MethodParameterInfo;
import org.jboss.jandex.ParameterizedType;
import org.jboss.jandex.Type;
import org.jboss.jandex.TypeVariable;
import org.jboss.jandex.WildcardType;
import org.jboss.logging.Logger;

import io.quarkus.deployment.annotations.BuildStep;
import io.quarkus.deployment.builditem.CombinedIndexBuildItem;
import io.quarkus.deployment.dev.RecompilationDependenciesBuildItem;
import io.quarkus.deployment.dev.RuntimeUpdatesProcessor;

/**
 * Processor which figures out annotation marked recompilation dependencies. This is needed to solve the problem of "how to
 * recompile classes generated by annotation processor, where the generated class accesses another type in the users code".
 * </p>
 * Right now we statically set org.mapstruct.Mapper as annotation we search for.
 * </p>
 * From these annotated classes, the set of all directly referenced types is collected. This includes all fields, method return
 * types, and method parameters type of any visibility of the full class hierarchy.
 * </p>
 * Then based on the set of directly referenced types, another set of indirectly referenced types is discovered. This includes
 * all the public, protected, and package private fields, method return types, and method parameters types of the current type
 * and upwards in the hierarchy. Package private and protected (which is also package private) member are only included, if they
 * are declared on a class in the same package as the annotated class. This step is addition repeated for each additional public
 * referenced type, until every direct or public type was visited once.
 * </p>
 * Result is a Mapping of the referenced type to the annotated class. Note that no chaining information between the referenced
 * types is kept. Since for the recompilation to take place we just need to resolve later on from the dependency to the
 * annotated class. This discovery is repeated for all the configured annotations.
 * </p>
 *
 * @see RecompilationDependenciesProcessor
 * @see RecompilationDependenciesBuildItem
 */
public class AnnotationDependentClassesProcessor {

    private static final Logger LOGGER = Logger.getLogger(AnnotationDependentClassesProcessor.class);

    static Set<String> ANNOTATIONS = Set.of(MapstructNames.NAME_MAPPER.toString());

    @BuildStep
    public List<RecompilationDependenciesBuildItem> discoverAnnotationDependentClasses(
            CombinedIndexBuildItem combinedIndexBuildItem) {

        // Sometimes the annotation itself is not in a jandex index, but that is fine as long as we can find it
        // a bit overkill to resolve from String to DotName again, but then again this helper does a few more safety checks for us
        Set<DotName> recompileAnnotationNames = resolveConfiguredAnnotationNames(ANNOTATIONS,
                combinedIndexBuildItem.getComputingIndex());

        List<RecompilationDependenciesBuildItem> result = new ArrayList<>();
        for (DotName recompileAnnotationName : recompileAnnotationNames) {
            // the classes the annotation is applied on have to be in our index though.

            RecompilationDependenciesBuildItem RecompilationDependenciesBuildItem = determineDependencies(
                    combinedIndexBuildItem.getComputingIndex(), recompileAnnotationName);

            if (RecompilationDependenciesBuildItem != null) {
                result.add(RecompilationDependenciesBuildItem);
            }
        }

        return result;
    }

    private Set<DotName> resolveConfiguredAnnotationNames(Set<String> recompileAnnotations, IndexView index) {
        // quick check and warn if the annotation type even exists
        // warning is enough, we just optionally want to determine additional classes to recompile based on the configured recompileAnnotations
        Set<DotName> result = new HashSet<>();
        for (String recompileAnnotation : recompileAnnotations) {

            ClassInfo classByName = index.getClassByName(recompileAnnotation);
            if (classByName == null) {
                LOGGER.warnf("""
                        Configured recompile annotation type %s not found.\
                        Won't automatically recompile annotated classes when dependent classes change.""",
                        recompileAnnotation);
                continue;
            }

            if (!classByName.isAnnotation()) {
                LOGGER.warnf("""
                        Configured recompile annotation type %s is not an annotation class.""",
                        recompileAnnotation);
                continue;
            }

            result.add(classByName.name());
        }

        return result;
    }

    private RecompilationDependenciesBuildItem determineDependencies(IndexView index, DotName supportedAnnotationName) {
        Collection<AnnotationInstance> annotations = index.getAnnotations(supportedAnnotationName);
        Map<DotName, Set<DotName>> dependencyToAnnotatedClasses = new HashMap<>();
        for (AnnotationInstance annotation : annotations) {
            ClassInfo annotatedClass;
            try {
                annotatedClass = annotation.target().asClass();
            } catch (Exception exception) {
                LOGGER.warnf(exception, "Annotation %s is not placed on a class. Target %s instead. Skipping.",
                        supportedAnnotationName, annotation.target());
                continue;
            }

            Set<DotName> referencedTypes = collectAllReferencedTypeNames(annotatedClass, index);

            Set<DotName> dependencies = new HashSet<>();
            for (DotName referencedType : referencedTypes) {
                collectVisibleTypeNames(dependencies, referencedType, index, annotatedClass.name());
            }

            for (DotName dependency : dependencies) {
                dependencyToAnnotatedClasses.computeIfAbsent(dependency, k -> new HashSet<>()).add(annotatedClass.name());
            }
        }

        if (dependencyToAnnotatedClasses.isEmpty()) {
            return null;
        }

        return new RecompilationDependenciesBuildItem(dependencyToAnnotatedClasses);
    }

    private Set<DotName> collectAllReferencedTypeNames(ClassInfo startingClass, IndexView index) {
        Set<DotName> visited = new HashSet<>();
        ArrayDeque<DotName> stack = new ArrayDeque<>();
        stack.add(startingClass.name());

        Set<DotName> referencedTypeNames = new HashSet<>();
        while (!stack.isEmpty()) {
            DotName currentClassName = stack.poll();
            if (!visited.add(currentClassName)) {
                continue;
            }
            if (currentClassName.equals(DotName.OBJECT_NAME)) {
                continue;
            }

            ClassInfo classInfo = index.getClassByName(currentClassName);
            if (classInfo == null) {
                continue;
            }

            // search up and down the inheritance chain
            stack.add(classInfo.superClassType().name());
            stack.addAll(classInfo.interfaceNames());

            for (ClassInfo knownDirectSubclass : index.getKnownDirectSubclasses(currentClassName)) {
                stack.add(knownDirectSubclass.name());
            }
            for (ClassInfo knownDirectImplementation : index.getKnownDirectImplementations(currentClassName)) {
                stack.add(knownDirectImplementation.name());
            }

            // Collect types of any fields in the inheritance chain of the annotated class
            for (FieldInfo field : classInfo.fields()) {
                if (!field.isSynthetic()) {
                    extractTypeNames(field.type(), referencedTypeNames);
                }
            }

            // Collect types of any methods in the inheritance chain of the annotated class
            for (MethodInfo method : classInfo.methods()) {
                if (!method.isSynthetic()) {
                    extractTypeNames(method.returnType(), referencedTypeNames);
                    for (MethodParameterInfo parameter : method.parameters()) {
                        extractTypeNames(parameter.type(), referencedTypeNames);
                    }
                }
            }
        }

        return referencedTypeNames;
    }

    private void extractTypeNames(Type type, Collection<DotName> names) {
        switch (type.kind()) {
            case CLASS -> names.add(type.name());
            case PARAMETERIZED_TYPE -> {
                names.add(type.name());
                ParameterizedType parameterizedType = type.asParameterizedType();
                for (Type argument : parameterizedType.arguments()) {
                    // useful for nested generics, e.g. Map<String, List<SomeType>>
                    extractTypeNames(argument, names);
                }
            }
            case WILDCARD_TYPE -> {
                names.add(type.name());
                WildcardType wildcardType = type.asWildcardType();
                if (!ClassType.OBJECT_TYPE.equals(wildcardType.extendsBound())) {
                    extractTypeNames(wildcardType.extendsBound(), names);
                } else if (wildcardType.superBound() != null) {
                    extractTypeNames(wildcardType.superBound(), names);
                }
            }
            case TYPE_VARIABLE -> {
                names.add(type.name());
                TypeVariable typeVariable = type.asTypeVariable();
                for (Type bound : typeVariable.bounds()) {
                    extractTypeNames(bound, names);
                }
            }
            case ARRAY -> extractTypeNames(type.asArrayType().constituent(), names);
        }
    }

    private void collectVisibleTypeNames(Set<DotName> collectedTypes, DotName startingPoint, IndexView index,
            DotName annotatedClassName) {
        ArrayDeque<DotName> stack = new ArrayDeque<>();
        stack.add(startingPoint);

        while (!stack.isEmpty()) {
            DotName currentClassName = stack.poll();
            if (!collectedTypes.add(currentClassName)) {
                // already know about this property type
                continue;
            }
            if (currentClassName.equals(DotName.OBJECT_NAME)) {
                continue;
            }

            ClassInfo classInfo = index.getClassByName(currentClassName);
            if (classInfo == null) {
                continue;
            }

            // only search upwards. The annotated class should only contain references to the public types it can see, i.e. our own and our parents public types
            stack.add(classInfo.superClassType().name());
            stack.addAll(classInfo.interfaceNames());

            for (FieldInfo field : classInfo.fields()) {
                if (isVisibleForAnnotatedClass(field.flags(), classInfo, annotatedClassName) && !field.isSynthetic()) {
                    extractTypeNames(field.type(), stack);
                }
            }

            for (MethodInfo method : classInfo.methods()) {
                if (isVisibleForAnnotatedClass(method.flags(), classInfo, annotatedClassName) && !method.isSynthetic()) {
                    extractTypeNames(method.returnType(), stack);
                    for (MethodParameterInfo parameter : method.parameters()) {
                        extractTypeNames(parameter.type(), stack);
                    }
                }
            }
        }
    }

    private boolean isVisibleForAnnotatedClass(short flags, ClassInfo declaringClass, DotName annotatedClassName) {
        if (Modifier.isPublic(flags)) {
            return true;
        }

        boolean isProtected = Modifier.isProtected(flags);
        boolean isPackagePrivate = !isProtected && !Modifier.isPrivate(flags);
        if (isProtected || isPackagePrivate) {
            return declaringClass.name().packagePrefix().equals(annotatedClassName.packagePrefix());
        }

        return false;
    }
}
